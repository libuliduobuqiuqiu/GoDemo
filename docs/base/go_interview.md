## 语法

如何查看当前汇编代码？如何定位代码中指定的源码
```bash
go build -gcflags="-S" main.go
```

new和make的区别:
- new是传入一个类型，申请内存空间，并初始化为对应的零值，返回该内存空间的指针（主要初始化对象为值类型）
- make只用来为引用类型对象slice、chan、map的内存创建，返回的是类型本身；


Go的defer语句?
- 可以理解为栈，先进后出执行顺序
- return在函数中不是原子操作：1. 返回值赋值 2. 调用执行defer语句 3. 返回返回值给调用函数

闭包操作

### slice
nil slice和空slice有什么区别？
> nil slice赋值的时候会出现越界错误，因为只声明了slice，没有实例化对象；

**Go slice扩容策略？**
slice和map传递过程中有什么区别？

### map

Map的底层实现? 
哈希函数?
扩容策略?
查找性能?
碰撞？

### interface
动态语言的特点
> 变量绑定的类型是不确定的，在运行期间才能确定。函数和方法可以接受任意类型的参数，且调用时不用检查参数类型，不用实现接口。

关于鸭子类型
> 鸭子类型是动态语言一种对象推断策略，关注的是对象的行为，而不是对象类型本身。Go作为一种静态语言通过接口完美支持鸭子类型，实际上是Go编译器作了隐匿的转换工作。

关于方法
> 方法是在函数的基础上添加一个接收者，接收者可以是值类型也可以是指针类型。调用方法时，值类型调用者和指针类型调用者，无需固定接收者类型的方法，都可以调用。

值接收者和指针接收者
| - | 值接收者 | 指针调用者 |
| ---- | ----| ----|
| 值类型调用者 | 方法相当于传递调用者的一个副本，类似"传值" | 使用值的引用调用方法|
| 指针类型调用者 | 指针被解引用为值 | 实际上也是“传值”，方法里的操作会影响调用者 |

两者分别在何时使用?
- 值接收器方法，无论调用者是指针还是值都只是修改其副本，不影响调用者，比较适用一些内置的类型；
- 指针接收器方法，当出现大型结构体和数组时，指针接收器更加高效，避免每次调用方法时的值拷贝；

iface和eface?
> iface和eface都是描述接口的底层结构体，iface描述的接口包含方法，eface则是不包含任何方法的空接口(interface)；

接口的动态类型和动态值？
> iface结构体中有两个字段，tab是接口表指针，指向类型信息，data是数据指针，指向具体的数据。这两个分别成为动态类型和动态值。接口值包括动态类型和动态值。
所以当接口值的零值指的是动态类型和动态值为nil，只有两部分都为nil时，才会被认为接口值==nil；

编译器检测类型是否实现了接口
```go
var d types.DeviceHandler = (*DevPHandler)(nil)
```
> 上述赋值语句过程会出现隐式转换，编译器会检测等号右边的类型是否实现了左边等号规定的函数

接口值和nil进行比较时，会比较接口值的类型T和值V是否都是unset状态

### reflect
> Golang提供的反射机制，就是在编译过程中无法确定变量类型，需要在运行时动态对变量更新、访问、调用它们的方法；

常用场景：
1. 不能明确接口调用哪个函数，需要更具传入的参数在运行时决定；
2. 不能明确传入函数时的参数类型，需要运行时处理任意对象；

反射的缺点：
1. 反射代码的可阅读性；
2. 反射代码不能再编译期间就发现相应的问题，有可能运行很久才会发现；
3. 反射性能差;

利用反射机制的DeepEqual深度比较

### unsafe

Go指针的限制：
1. Go指针不能进行数学运算；
2. Go指针不同类型不能相互转换；
3. Go指针不同类型之间不能通过!= 和 == 比较;
4. Go指针不同类型之间不能相互赋值；


## 网络

Go的http包实现原理？

