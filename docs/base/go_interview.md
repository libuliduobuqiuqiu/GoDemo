## 语法

如何查看当前汇编代码？如何定位代码中指定的源码
```bash
go build -gcflags="-S" main.go
```

new和make的区别:
- new是传入一个类型，申请内存空间，并初始化为对应的零值，返回该内存空间的指针（主要初始化对象为值类型）
- make只用来为引用类型对象slice、chan、map的内存创建，返回的是类型本身；


Go的defer语句?
- 可以理解为栈，先进后出执行顺序
- return在函数中不是原子操作：1. 返回值赋值 2. 调用执行defer语句 3. 返回返回值给调用函数

闭包操作

### slice
nil slice和空slice有什么区别？
> nil slice赋值的时候会出现越界错误，因为只声明了slice，没有实例化对象；

**Go slice扩容策略？**
slice和map传递过程中有什么区别？

### map

Map的底层实现? 
哈希函数?
扩容策略?
查找性能?
碰撞？

### interface
动态语言的特点
> 变量绑定的类型是不确定的，在运行期间才能确定。函数和方法可以接受任意类型的参数，且调用时不用检查参数类型，不用实现接口。

关于鸭子类型
> 鸭子类型是动态语言一种对象推断策略，关注的是对象的行为，而不是对象类型本身。Go作为一种静态语言通过接口完美支持鸭子类型，实际上是Go编译器作了隐匿的转换工作。

关于接口
> 接口是定义一种规范，描述类的行为和功能，不做具体实现。

关于方法
> 方法是在函数的基础上添加一个接收者，接收者可以是值类型也可以是指针类型。调用方法时，值类型调用者和指针类型调用者，无需固定接收者类型的方法，都可以调用。

值接收者和指针接收者
| - | 值接收者 | 指针调用者 |
| ---- | ----| ----|
| 值类型调用者 | 方法相当于传递调用者的一个副本，类似"传值" | 使用值的引用调用方法|
| 指针类型调用者 | 指针被解引用为值 | 实际上也是“传值”，方法里的操作会影响调用者 |

两者分别在何时使用?
- 值接收器方法，无论调用者是指针还是值都只是修改其副本，不影响调用者，比较适用一些内置的类型；
- 指针接收器方法，当出现大型结构体和数组时，指针接收器更加高效，避免每次调用方法时的值拷贝；

iface和eface?
> iface和eface都是描述接口的底层结构体，iface描述的接口包含方法，eface则是不包含任何方法的空接口(interface)；

接口的动态类型和动态值？
> iface结构体中有两个字段，tab是接口表指针，指向类型信息，data是数据指针，指向具体的数据。这两个分别成为动态类型和动态值。接口值包括动态类型和动态值。
所以当接口值的零值指的是动态类型和动态值为nil，只有两部分都为nil时，才会被认为接口值==nil；

编译器检测类型是否实现了接口
```go
var d types.DeviceHandler = (*DevPHandler)(nil)
```
> 上述赋值语句过程会出现隐式转换，编译器会检测等号右边的类型是否实现了左边等号规定的函数

类型断言和类型转换有什么区别？
- Go类型转换不允许隐式转换，赋值=两边不允许出现类型不一致的变量。类型转换和类型断言本质上是把一个类型转换成另外一个类型，区别在于类型断言是对接口变量进行操作
- 类型转换是针对类型转换前后的变量要相互兼容
- 由于空接口interface{}里面没有定义任何函数，因此所有类型都实现了空接口，所以当一个形参是interface{}时，需要对形参进行断言，得到真实的类型

接口转换的原理？
1. 具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
2. 具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
3. 而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。

通过interface实现多态？
> 多态指的是同一个接口，使用不同的实例执行不同的操作
- 一种类型具有多种类型的能力；
- 允许不同的对象对同一消息进行灵活的反应；
- 非动态语言必须使用继承或者接口来实现；


接口值和nil进行比较时，会比较接口值的类型T和值V是否都是unset状态

### reflect
> Golang提供的反射机制，就是在编译过程中无法确定变量类型，需要在运行时动态对变量更新、访问、调用它们的方法；

常用场景：
1. 不能明确接口调用哪个函数，需要更具传入的参数在运行时决定；
2. 不能明确传入函数时的参数类型，需要运行时处理任意对象；

反射的缺点：
1. 反射代码的可阅读性；
2. 反射代码不能再编译期间就发现相应的问题，有可能运行很久才会发现；
3. 反射性能差;

利用反射机制的DeepEqual深度比较

### unsafe

Go指针的限制：
1. Go指针不能进行数学运算；
2. Go指针不同类型不能相互转换；
3. Go指针不同类型之间不能通过!= 和 == 比较;
4. Go指针不同类型之间不能相互赋值；


## 网络

Go的http包实现原理？

