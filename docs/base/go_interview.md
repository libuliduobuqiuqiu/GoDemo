## 并发

### Goroutine

进程、线程、协程之间的区别？

CSP模型
> CSP模型核心思想：不要通过共享内存进行通信，而是要通过通信共享内存；

Go GMP 调度模型?
- G(Goroutine): 协程，计算任务，需要执行的代码和上下文
- M(Machine)：系统线程，执行实体，想要在CPU执行代码必须通过线程
- P(Processer): 处理器, 为Goroutine和Machine的调度器

GMP 调度:
> 并发过程中如何进行调度，不同场景下的调度方式是？


并发和并行之间的区别：
- 并发指的是在一个处理器上，一段时间内执行多个任务，更加注重的是任务之间交替执行。（多个事件在同一时间间隔内交替执行）
- 并行指的是多个处理器上同时处理多个任务（不同事件在多个实体是同时执行）

Goroutine 数量怎么限制？能在多少个线程上运行？
> Channel sync.WaitGroup

Go的Selec语句？Select机制？
> Select监听Channel，每个case是一个事件，如果所有case事件阻塞会执行default语句逻辑

Goroutine 退出：
- for-range 检测通道是否关闭
- select-case


### Channel
Channel是什么？为什么安全？
- 发送和接收都是原子性的;
- Channel是一个管道，通过管道进行通信；
- Go的并发设计思想就是通过通信来共享内存，而不是通过内存来通信（前者通过Channel、后者通过锁）


Go Channel的实现？

### 锁

Go的几种锁（使用场景）：
- 互斥锁(sync.Mutex)
- 读写锁(sync.RWMutex)-写时不可读、读时不可写、不可并发写、可以并发读
- sync.Map(并发安全的底层原理)

数据竞争如何解决？
> 锁、Channel、CAS操作

原子操作，CAS算法

### WaitGroup

并发场景：
- 限制主协程在所有协程完成后才能执行；(sync.WaitGroup)


### Context
Context使用场景?
> 需要统一对多个goroutine执行“取消”动作，常用于并发控制和超时控制；(也可用于传递共享数据)

Context.Value的查找过程是怎样？
- context.Value设置value，通过将context包起来，设置key，value；
- context查找过程中，每个context指向父context，根据指向循环遍历，然后判断比较是否存在对应的value(递归查找过程)；

context如何被取消？
- Done()返回一个只读的Channel，通过select，只有当chanel的关闭的时候才能读取到零值；
- Cancel()，关闭Channel，c.done；递归取消它的所有子节点；从父节点删除自己。达到的效果就是通过关闭channel，然后递归发送取消信号到它所有子节点；

Context接口：
- Done() <- chan struct{}:当Context被取消或者到Dealine，返回一个channel
- Err() error: 当channel Done被关闭后，返回context取消原因
- Dealine() (deadline time.Time, ok bool)：返回context截止时间
- Value()：返回之前设置key的value

Go语言栈空间管理?

## 垃圾回收

> Garbage Collection，垃圾回收，是一种自动内存管理的机制；

GC可抽象成两个组件：
- 赋值器：维护和修改对象之间引用关系的组件
- 回收器：根据对象之间的引用维护标记，并且根据标记执行GC

常见GC存在形式：
- 追踪式GC：从根对象出发，根据对象之间的引用信息，扫描整个堆确定需要保留的对象，回收可回收的对象；
- 引用计数式GC：每个对象自身包含一个引用计数器，当计数器归零是自动回收；

常见GC算法的实现方式：
- 追踪式：
  1. 标记清除，对存活的对象进行标记，清除可以回收的对象；
  2. 标记整理，在标记过程中，将对象尽可能整理到一块连续的内存上；
  3. 增量式，将标记和清除分批执行，每次执行很小的部分，从而增量的推进垃圾回收；
  4. 增量式整理，在增量式基础上增加对象的整理过程；
  5. 分代回收，根据对象的存活时间进行分类，存活时间大于某个时间为老年代，存活时间小于某个时间为年轻代，根据分代假设对对象进行回收；
- 引用计数：根据对象的引用计数进行回收，当引用计数为零时立即回收

### 三色标记清除法(非分代、非紧缩、并发)

标记清除最大缺点和难点是什么？如何实现正确的内存回收？
- 由于赋值器会不断修改对象之间的引用关系，如果回收器需要执行GC标记清理操作，需要让赋值器停止，回收器执行回收；
- 这一个停止的时间就叫做STW，可以理解为从STOP THE WORLD 到 START THE WORLD的时间间隔；
- STW是为了保证垃圾回收在实现上的正确性，防止无止境内存增长等问题，同时STW越长，对赋值器影响也就越大；
- 标记清除最大的难点就是在STW时间上，在Golang中为了缩短STW和提高代码执行效率，采用了赋值器和回收器并发运行的做法，相当于回收器执行标记清除这一步骤提前了部分；
- 而Golang为了保证在并发情况下，保证内存回收的正确性，采用了混合写屏障+三色标记清除法；

三色标记清除法将对象分成三种颜色：
- 白色(可能死亡), 未被根对象访达的对象，回收阶段，所有对象均为白色。当回收结束后，白色对象均为不可达；
- 灰色(波面), 能被根对象访达的对象，但仍然需要对一个或者多个指针进行扫描，因为他们可能指向白色对象；
- 黑色(确定存活),能被跟根对象访达的对象，并且所有的字段都已经被扫描，黑色对象中任何一个指针都不可能指向白色对象；

三色标记清除法流程：
1. 标记：
  - 一开始所有对象为白色，先将跟根对象染成灰色，表示能访达。但是对于回收器来说，其他对象的引用不明确；
  - 从灰色对象中，挑选一个染成黑色，并将其引用的对象染成灰色，表示该对象能访达，已明确引用关系，但是对于引用对象的引用还不明确；
  - 重复步骤2，直至只有黑色和白色对象;
2. 回收：
  - 当染色完成之后，将所有白色对象进行回收，将黑色对象再次染白;

理解垃圾回收器的正确性：
> 不应出现对象的丢失，也不应错误的回收不需要回收的对象；

三色标记清除过程中可能破坏回收器正确性：
1. 赋值器修改对象图，导致某一个黑色对象引用白色对象；
2. 从灰色对象出发过程中，到达白色度对象的，未经访问的路劲被赋值器破坏；
当解决条件1时可以称为弱三色不变性、满足解决条件1和2则称为强三色不变性；

赋值器屏障作为一种同步机制，使赋值器操作时，能够“通知”回收器


混合写屏障？

Go 逃逸分析？

Go pprof性能分析工具

## 语法

如何查看当前汇编代码？如何定位代码中指定的源码
```bash
go build -gcflags="-S" main.go
```

new和make的区别:
- new是传入一个类型，申请内存空间，并初始化为对应的零值，返回该内存空间的指针（主要初始化对象为值类型）
- make只用来为引用类型对象slice、chan、map的内存创建，返回的是类型本身；


Go的defer语句?
- 可以理解为栈，先进后出执行顺序
- return在函数中不是原子操作：1. 返回值赋值 2. 调用执行defer语句 3. 返回返回值给调用函数

闭包操作

### slice
nil slice和空slice有什么区别？
> nil slice赋值的时候会出现越界错误，因为只声明了slice，没有实例化对象；

**Go slice扩容策略？**
slice和map传递过程中有什么区别？

### map

Map的底层实现? 
哈希函数?
扩容策略?
查找性能?
碰撞？

### interface
Go 值接收器和指针接收器？

接口值和nil进行比较时，会比较接口值的类型T和值V是否都是unset状态

### reflect
> Golang提供的反射机制，就是在编译过程中无法确定变量类型，需要在运行时动态对变量更新、访问、调用它们的方法；

常用场景：
1. 不能明确接口调用哪个函数，需要更具传入的参数在运行时决定；
2. 不能明确传入函数时的参数类型，需要运行时处理任意对象；

反射的缺点：
1. 反射代码的可阅读性；
2. 反射代码不能再编译期间就发现相应的问题，有可能运行很久才会发现；
3. 反射性能差;

利用反射机制的DeepEqual深度比较

### unsafe

Go指针的限制：
1. Go指针不能进行数学运算；
2. Go指针不同类型不能相互转换；
3. Go指针不同类型之间不能通过!= 和 == 比较;
4. Go指针不同类型之间不能相互赋值；


## 网络

Go的http包实现原理？

