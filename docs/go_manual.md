## Go

> 旨在整理Go学习有关的框架和路线，同时补充有关Go面试题目；


## 提纲

### 基础

Base:
1. 命名（驼峰式命名规范、名字的开头字母大写决定了包外的可见性）
2. 声明var,const,type,func（变量、常量、类型、函数实体对象）
3. 变量:
  - var关键字声明(默认变量类型对应的零值)
  - 短变量声明(在同级词法作用域中是赋值，不同级作用域是重新声明)
  - 指针（指针的值保存的是变量的内存地址）
  - new(函数创建一个变量，初始化变量零值，返回变量地址）
  - 变量的生命周期-》Go的GC机制
4. 赋值
5. 类型（新创建类型首字符大写可导出、可以对命名类型定义关联的方法集）
6. 包和文件（导入包、包的初始化）
7. 作用域（全局作用域、包级作用域、局部作用域、函数级作用域）从内部词法作用域往全局作用域寻找

基础数据类型：
1. 整型
2. 浮点数
3. 复数
4. 布尔型
5. 字符串（不可变的字节序列）：
  - 字符串面值（可解析字符串面值-双引号、原生字符串面值-反引号）
  - 字符串和bytes切片(strings、bytes、strconv、unicode)
  - 字符串和数字的转换
6. 常量(编译期间确定，iota常量生成器)

复杂数据类型：
1. 数组（固定长度的特定类型组成的序列）
2. 切片（可变长的冬天序列：指针、长度、容量组成）：
  - 切片底层扩容策略
  - 待定
3. Map:
  - 遍历、赋值、删除、扩容
  - 底层实现原理
  - 线程安全
4. 结构体（由零个或者多个任意类型的值聚合成实体）：
  - 结构体嵌入和匿名成员
5. JSON、文本和HTML模板

### 函数

函数：
1. 函数声明（函数名、形参列表、返回值（可省略）、函数体）：
  - 实参通过值的方式进行传递
  - 可变参数(参数类型之前加上省略号)
2. 多返回值：
  - bare return
4. 错误（错误处理策略）：
  - 传播错误
  - 可预知错误，重试操作
  - 输出错误信息并结束程序（仅在main中执行，库函数往上抛出错误）
  - 输出打印log错误信息，程序不中断执行
  - 忽略错误
5. 函数值（可赋值、传递、返回、拥有类型）
6. 匿名函数（函数字面量就是创建一个匿名函数并且作为值使用的语法结构）
  - 捕获迭代变量（在循环过程中，所有的函数值共享同一个循环变量，有可能出现预期以外的异常）
7. Defer函数(执行顺序和声明顺序相反)
8. Panic异常/Recover捕获异常

Go语言和OOP编程?
- 封装
- 继承
- 多态

### 方法

方法：
1. 方法声明（函数名前加上变量，该函数就会绑定到这个类型，成为这个类型的一个方法）:
  - 值接收器
  - 指针接收器
2. 内嵌结构体扩展类型
3. 方法值和方法表达式（快捷将方法赋给某个变量，不需要指定接收器即可调用）
4. 封装（将数据和操作数据的方法绑定在一起，隐藏内部细节，提供统一访问接口，防止外部调用对对象内部的值任意进行修改）

值接收器和指针接收器？
- 两者有什么区别，值调用者和指针调用者调用对应接收器，会出现什么情况？
- 两者适用的场景是什么？

### 接口

接口：
1. 接口类型（接口就是一系列方法的集合，一个实现了这些方法的具体类型就是这个接口类型的实例）
2. 实现接口的条件（一个类型拥有一个接口需要的所有方法，这个类型就是实现了这个接口）
  - iface
  - eface
3. 接口值（由具体类型和具体类型的值组成，即接口的动态类型和动态值。而赋值过程是具体的类型通过隐式转换成接口类型）
4. 类型断言（判断操作对象的动态类型和断言的类型是否匹配）
  - 断言的类型是具体类型(检查的是类型X，断言的类型是T，断言成功后X的类型为T的动态值)
  - 断言的类型是接口类型(断言检查成功后则是另外的接口值)
5. 类型分支（基于接口值的动态类型）

Go的接口和其他面向对象编程语言类继承接口有什么区别？

### 并发编程

Goroutines和Channels：
1. CSP并发编程模型
2. Goroutines(并发的执行单元)
3. Channels(Goroutines之间同步和通行的机制):
  - 不带缓存的Channels(仅仅用于goroutines之间同步的消息事件，可以用空结构体作为channel的类型/bool、int同样可以)
  - 串联的Channels（Pipeline）
  - 单方向的Channel
  - 带缓存的Channels
4. 并发的循环（Sync.WaitGroup)
5. 基于Select的多路复用
6. 并发的退出

基于共享变量的并发：
1. 关于数据竞争（在两个以上的Goroutines同时操作相同的变量，并且最少一个进行写操作时发生），避免数据竞争几个思路：
  - 避免使用变量（或者说是避免使用不安全的变量，对于类似Sync.Map并发安全的数据结构可以使用）
  - 避免从多个Goroutines访问变量；
  - 允许多个Goroutines访问变量，但是在同一时刻只允许一个goroutine访问(互斥)；
2. 互斥
  - Channel
  - sync.Mutex（互斥锁、Go不支持重入锁）
  - sync.RWMutex（读写锁，允许只读操作并发执行，但是写操作完全互斥，“多读单写锁”）写锁，不可读写，读锁，不可写，可读；
3. 竞争条件检测（编译时补充-race参数）
4. Goroutines 和 线程
  - 内存占用
  - 创建和销毁
  - 切换

Goroutines调度?

### 包管理

包和工具
1. 包声明、导入声明、匿名导入
2. 包和命名（简洁、描述性、无歧义）
3. 工具：
  - 工作区结构（GOPATH:工作区目录、GOROOT:Go安装目录）
  - Go Modules（常用操作：初始化、更新某个版本的依赖、下载依赖，下载依赖去除不必要的依赖，依赖复制到vendor下）
  - Go Modules工作机制
  - 内部包无法导入（internal）

Go Modules工作机制？
- 初始化go.mod记录所有依赖模块的信息
- 依赖解析下载对应版本的模块，保存到本地的模块缓存
- 相应依赖模块的版本可以通过go.mod进行管理
- 对应的依赖更新可以通过go get对依赖模块进行下载更新
- 版本的校验与锁定通过go.sum的哈希值校验模块的完整性和安全性

### 测试

测试：
1. go test（所有命名为*_test.go的文件：测试函数、基准测试函数、示例函数）
2. 测试函数（命名Test为开头，可选的后缀名也必须以大写字母开头，导入testing包）
3. 白盒测试(根据软件内部逻辑和结构设计测试用例)、黑盒测试(测试公开的文档和API行为)
4. 测试覆盖率
5. 基准测试(测定一个程序在固定的工作负载下的性能，命名为Benchmark为前缀名，导入testing.B, go test -bench)
6. 剖析（go test开启标志参数生成各种分析文件-cpuprofile/-blockprofile/-memprofile）
7. 示例函数（命名Example为开头, 没有函数参数和返回值)

### 反射

反射：
1. Reflect的使用场景（程序在运行期间能够动态修改变量的值、调用函数和方法，并且可以创建新的数据类型和变量）
2. reflect.Type 和 reflect.Value
3. 通过reflect.Value 修改值
4. 获取结构体标签
5. 显示一个类型的方法集（NumMethod())

TypeOf 和 ValueOf
- TypeOf 返回传入interface对应的反射类型
- ValueOf 返回一个新的Value，初始化为传入interface的实际值
